---
title: docker_yandex_pract
author: Roman Vavilov
date: '2022-05-21 14:17'
---

[Запись воркшопа](https://drive.google.com/file/d/1xkvdtWNzaR5KsVelMNM-_xkscoXLwC8P/view)
[Презентация](https://docs.google.com/presentation/d/1b1puthf3Kk3dwNvzHf8g8MtY5enJf71HdkzhrSHkH3Y/edit?usp=sharing)
[Репозиторий с примерами](https://github.com/emorozov/docker-workshop)

# Notes

Контейнеры docker выполняются на ядре родительской операционной системы, тогда как VM загружает свое ядро и эмулирует железо. Docker позволяет ограничивать достуные ресурсы (память, cpu и т.д.).

Control group - технология на которой основан docker. 2006 год начало разработки сотрудниками гугл.

Docker основан на lxc, но потом переписан на собственный движок. Еще одна система - system [nspawn](https://wiki.archlinux.org/title/Systemd-nspawn).

По дефолту докер процессы крутятся в группе 0, поэтому не затрагивают сильно процессы родительской ОС. TODO: уточнить

Cтандартизация контейнеров (кубернетис и докер) кубернетис в последних версиях перешел на более стандартизированный формат контейнеров. TODO: уточнить

Пространство имен
Образ контейнера - статическая сущность - набор файлов (архив)
Контейнер - динамическая исполняемая сущность - процесс - создающийся на основе образа

Образ контейнера изолирован своем пространстве имен. Каждый образ контейнера все его файлы находятся в своем пространстве имен

Также и выполняемый контейнер находится в своем пространстве имен процесса. Названия процессов (ps) тоже чувствительная информация. Поэтому контейнер видит только свои процессы, а не процессы родительской ОС. Он существует в дочернем для себя пространстве имен.

<br>

___
# Docker container

Container - эфемерная сущность. Все изменения записываются в тонкий слой поверх образа контейнера - они исчезают после остановки контейнера.
Но существует потребность в постоянном хранилище - для этого есть тома (volumes), которые можно монтировать в контейнер.

Client к демону докера - cli. Демон запущен на хостовой ОС.
Registry - хранилище образов контейнера, например hub.docker.com

Реализация docker на bash в 100 строк - [github p8952 bocker](https://github.com/p8952/bocker)

## Как создавать контейнеры

```Shell
$ docker run --interactive --tty --name hello-template bash bash

-i / --interactive - образ контейнера получает доступ к вводу
-tty - получает доступ к выводу
(обе команды можно сократить до -it)
--name - если этот параметр не указан, то докер придумает длинный идентификатор
bash - название образа из которого будет создан контейнер
bash - аргумент, который будет передан в контейнер
```

`docker start` - запустить уже остановленный контейнер.

## Как создавать образы из контейнера

```Shell
$ docker commit hello-template hello
```
После того как мы изменили контейнера (например, создали там файл) - мы можем остановить запущенный процесс контейнера - при этом файловая система остановленного контейнера пока жива. Остановленный контейнер еще хранит изменения. После того как мы удалим контейнер из списка `docker ps -a`.
Аргумент `--rm` удаляет контейнер из списка после остановки контейнера и удаляет все данные соответственно.
Нужно выполнить `docker commit [container-name] [new image name]` 

утилита dive позволяет просматривать слои (содержимое) контейнера

### Как войти в запущенный контейнер

```Shell
$ docker exec -it hello-template bash // запустить bash в контейнере
```

Если выполнить `docker run` - то запустится еще один экземпляр такогоже контейнера.

<br>

___
# Docker file

## Как конструировать образ (image)

Имеем `Dockerfile` в текущем каталоге.
```Docker
FROM python:3.10

COPY hello.py .

CMD ["./hello.py"]
```

FROM указывает базовый образ контейнера (все докерфайлы начинаются с FROM)
COPY hello.py . берет файл из каталога хостовой операционной системы и копирует в контейнер (добавит слой в котором находится этот файл)
CMD ["./hello.py"] - какая команда исполняется при `docker run` - может быть в Dockerfile только одна такая команда (в отличие от RUN)

## Как собрать контейнер

```Shell
$ docker build . -t hello

. - значит найти в текущем каталоге Dockerfile
-t - Name and optionally a tag in the 'name:tag' format
```

Новый созданный образ хранится где-то во внутренних каталогах докера (зависит от версии докера и драйвера).

## Как собрать контейнер с зависимостями 

RUN - выполняет любую линуксовую команду внутри контейнера. Все команды выполняются внутри контейнера от root - это не безопасно, но т.к. мы работаем в изолированной системе - то нормально.

```Dockerfile
FROM python:3.10

RUN pip install rich // может быть несколько таких команд, в отличие от CMD, которая только одна

COPY hello.py .

CMD ["./hello.py"]
```

## Образы из registry

`[имя образа]:<version>-alpine` - alpine - это название очень компактного дистрибутива линукса. Но если нужны какие-то хитрые библиотеки не всегда возможно установить их именно в `alpine`

`docker save` / `docker import` - позволяет записать образ в файл, перенести на другую машину и импортировать - но обычно это делается через registry, либо сборкой образа через Dockerfile TODO: возможно команды другие, уточнить

<br>

___
# Работа с контейнерами

## Как вывести логи

```Shell
$ docker logs [container-name]

-f / --follow - выводить логи на экран в процессе выполнения
```

Важно, что при создании контейнера логи выводились не в какой-то файл, который временный, а в стандартный поток вывода.


## Как в контейнер передать какие-то данные

Чтобы передать данные в исполнение в контейнер - нужно из контейнера выполнить скрипт который выводит stdout и передать данные из командной строки.

```Shell
$ cat ./my_script
#!/bin/bash

echo $1
```

```Shell
$ echo Hello world! | docker run -i --name hello-test --rm my_script
```

<br>

___
# Тома / Volumes

Том - это какой-то каталог, который мы можем монтировать в какое-то место образ. Данные в томе не исчезают после того, как контейнер удален. Один том может использоваться несколькими контейнерами. Напримен, база данных хранит данные в каких-то файлах - они должны хранится в томах.

```Shell
$ docker vlume create
// создаем том в хостовой системе (где-то внутри системы docker, нам не важно где)
// также можно подключить каталог хостовой системы в конкретном месте на диске
```

```Shell
$ docker run ... --volume [имя контейнера]:[имя тома]
```

# Сеть

Каждый контейнер запущен в отдельной сети, которая не имеет связи ни с одной другой сетью

```Shell
$ docker network create some-network
$ docker run ... ---network some-network
```

Тогда контейнеры могу общаться между собой (они подключены к одной сети).

По умолчанию, когда мы связываем контейнеры в сеть, docker использует мост (driver: bridge).

Нельзя запускать сервисы в контейнере на локалхосте - нужно 0.0.0.0, т.к. это изолированная сеть и нужен внешний адрес, чтобы достучаться извне.

<br>

___
# Docker compose

Docker compose позволяет собрать несколько контейнеров вместе и управлять ими

```Shell
$ docker-compose // v.1
$ docker compose // v.2 (нужно в настройках docker desktop для mac OS указать какую версию использовать)
```

Рассмотрим содержимое `docker-compose.yml`
```yml
services:
  exam-app:
    build: // Для команды build нужен Dockerfile
      context: .
    container_name: exam-app
    ports:
      - "8000:8000" // Внутренний порт сети контейнера 8000 сделать доступным для сети хоста на порте 8000
    depends_on: // 
      - exam-db

  exam-db:
    image: postgres:14
    container_name: exam-db
    environment:
      - POSTGRES_USER=exam
      - POSTGRES_PASSWORD=exam
    ports:
      - 5432
    volumes:
      - "db-volume:/var/lib/postgresql/data"

volumes:
  db-volume:
```

WORKDIR - указываем каталог по умолчанию при `docker run`

Рассмотрим `Dockerfile` используемый в docker-compose.yml
```Dockerfile
FROM python:3.10

# Disables the buffer for instant output of messages to stdout from processes.
ENV PYTHONUNBUFFERED=1

# Install system requirements
RUN apt-get update && \
    apt-get install -y libpq5 wait-for-it && \
    apt-get clean

## Install poetry
RUN pip install --no-cache-dir poetry==1.1.13

COPY exam /app

WORKDIR /app

## Install app requires
RUN poetry config virtualenvs.create false && \
    poetry install --no-interaction --no-ansi

RUN ./manage.py collectstatic --noinput

CMD wait-for-it exam-db:5432 -s -t 180 && ./manage.py runserver 0.0.0.0:8000
```

wait-for-it - утилита, которая ждет запуска базы данных, т.к. в `docker-compose.yml` прописано, что контейнер `exam-app` `depends_on` контейнер бд.

во внутренней сети докеры hostname совпадает с именем контейнера, поэтому для удобства задаем имя контейнера базы данных явно

`environment` - переменные окружения - для образа postgress - они указаны на сайте докера для этого образа.
Порт для базы данных мы не пробрасываем наружу, т.к. только контейнер веб-сервера будет обращаться к бд.
`volumes` - db-volume - это том, который создаст докер
`volume` в блоке базы данных - обращение к имени тома и путь

```Shell
$ docker compose build
$ docker compose up
```

`docker compose` позволяет объединять файлы, например при разработке что перезаписывать конфигурации для разных сред разработки (docker-compose.dev.yml, docker-compose.int.yml).

`docker-compose.override.yml` - автоматически перезаписывает конфигураю, в остальных случаях нужно прописывать файлы явно.

Можно прописать команду в make файле, yml файлы будут применяться в том порядке, в котором они указаны
```Shell
// development
$ docker compose \
  -f docker-compose.yml \
  -f docker-compose.dev.yml \ // dev file overrides previous one
  up

// production
$ docker compose \
  -f docker-compose.yml \
  -f docker-compose.bd.yml \
  up
```

<br>

___
# Docker swarm
TODO: продолжить изучение
